[
  {
    "description": "Builds a table schema from a geojson feature\neach schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here",
    "tags": [
      {
        "title": "param",
        "description": "a geojson feature   * @returns {string} schema",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "feature"
      },
      {
        "title": "private",
        "description": null,
        "type": null
      },
      {
        "title": "name",
        "name": "_buildSchemaFromFeature"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 1057,
          "column": 2
        },
        "end": {
          "line": 1069,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L1057-L1069"
    },
    "params": [
      {
        "title": "param",
        "description": "a geojson feature   * @returns {string} schema",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "feature"
      }
    ],
    "access": "private",
    "name": "_buildSchemaFromFeature",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "_buildSchemaFromFeature"
    ]
  },
  {
    "description": "Creates an index on a given table   *",
    "tags": [
      {
        "title": "param",
        "description": "the table to index",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "the name of the index    * @param {string} using - the actual field and type of the index",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "name"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "private",
        "description": null,
        "type": null
      },
      {
        "title": "name",
        "name": "_createIndex"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 988,
          "column": 2
        },
        "end": {
          "line": 997,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L988-L997"
    },
    "params": [
      {
        "title": "param",
        "description": "the table to index",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "the name of the index    * @param {string} using - the actual field and type of the index",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "name"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "access": "private",
    "name": "_createIndex",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "_createIndex"
    ]
  },
  {
    "description": "Creates a new table\nchecks to see if the table exists, create it if not",
    "tags": [
      {
        "title": "param",
        "description": "the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "name"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "private",
        "description": null,
        "type": null
      },
      {
        "title": "name",
        "name": "_createTable"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 1007,
          "column": 2
        },
        "end": {
          "line": 1048,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L1007-L1048"
    },
    "params": [
      {
        "title": "param",
        "description": "the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "name"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "access": "private",
    "name": "_createTable",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "_createTable"
    ]
  },
  {
    "description": "Creates the sql needed to insert the feature",
    "tags": [
      {
        "title": "param",
        "description": "the table to insert into",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "a geojson feature",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "feature"
      },
      {
        "title": "param",
        "description": "index value to use an id",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "i"
      },
      {
        "title": "private",
        "description": null,
        "type": null
      },
      {
        "title": "name",
        "name": "_insertFeature"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 565,
          "column": 2
        },
        "end": {
          "line": 575,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L565-L575"
    },
    "params": [
      {
        "title": "param",
        "description": "the table to insert into",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "a geojson feature",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "feature"
      },
      {
        "title": "param",
        "description": "index value to use an id",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "i"
      }
    ],
    "access": "private",
    "name": "_insertFeature",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "_insertFeature"
    ]
  },
  {
    "description": "Executes SQL again the DB\nuses connection pooling to connect and query",
    "tags": [
      {
        "title": "param",
        "description": "the sql to run",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "sql"
      },
      {
        "title": "param",
        "description": "the callback when db returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "private",
        "description": null,
        "type": null
      },
      {
        "title": "name",
        "name": "_query"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 966,
          "column": 2
        },
        "end": {
          "line": 979,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L966-L979"
    },
    "params": [
      {
        "title": "param",
        "description": "the sql to run",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "sql"
      },
      {
        "title": "param",
        "description": "the callback when db returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "access": "private",
    "name": "_query",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "_query"
    ]
  },
  {
    "description": "Check for any coded values in the fields\nif we find a match, replace value with the coded val",
    "tags": [
      {
        "title": "param",
        "description": "the name of field to look for",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "fieldName"
      },
      {
        "title": "param",
        "description": "the coded value",
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "value"
      },
      {
        "title": "param",
        "description": "a list of fields to use for coded value replacements",
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "fields"
      },
      {
        "title": "name",
        "name": "applyCodedDomains"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 124,
          "column": 2
        },
        "end": {
          "line": 135,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L124-L135"
    },
    "params": [
      {
        "title": "param",
        "description": "the name of field to look for",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "fieldName"
      },
      {
        "title": "param",
        "description": "the coded value",
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "value"
      },
      {
        "title": "param",
        "description": "a list of fields to use for coded value replacements",
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "fields"
      }
    ],
    "name": "applyCodedDomains",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "applyCodedDomains"
    ]
  },
  {
    "description": "Connect to the db with a connection string",
    "tags": [
      {
        "title": "param",
        "description": "the connection string to the db with user/pass/host/dbname",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "conn"
      },
      {
        "title": "param",
        "description": "an instance of koop, mainlt for central/shared logging",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "koop"
      },
      {
        "title": "param",
        "description": "callback for when the db is ready",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "optional"
      },
      {
        "title": "name",
        "name": "connect"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 20,
          "column": 2
        },
        "end": {
          "line": 42,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L20-L42"
    },
    "params": [
      {
        "title": "param",
        "description": "the connection string to the db with user/pass/host/dbname",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "conn"
      },
      {
        "title": "param",
        "description": "an instance of koop, mainlt for central/shared logging",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "koop"
      },
      {
        "title": "param",
        "description": "callback for when the db is ready",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "optional"
      }
    ],
    "name": "connect",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "connect"
    ]
  },
  {
    "description": "Get the count of distinct geohashes for a query",
    "tags": [
      {
        "title": "param",
        "description": "the table to query",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "precision"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "countDistinctGeoHash"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 857,
          "column": 2
        },
        "end": {
          "line": 874,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L857-L874"
    },
    "params": [
      {
        "title": "param",
        "description": "the table to query",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "precision"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "countDistinctGeoHash",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "countDistinctGeoHash"
    ]
  },
  {
    "description": "Determines if a range or like filter is needed   * appends directly to the sql passed in",
    "tags": [
      {
        "title": "param",
        "description": "a sql where clause",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "sql"
      },
      {
        "title": "param",
        "description": "a list of fields in to support coded value domains",
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "fields"
      },
      {
        "title": "name",
        "name": "createFilterFromSql"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 221,
          "column": 2
        },
        "end": {
          "line": 230,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L221-L230"
    },
    "params": [
      {
        "title": "param",
        "description": "a sql where clause",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "sql"
      },
      {
        "title": "param",
        "description": "a list of fields in to support coded value domains",
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "fields"
      }
    ],
    "name": "createFilterFromSql",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "createFilterFromSql"
    ]
  },
  {
    "description": "Creates a geohash from a features\ncomputes the centroid of lines and polygons",
    "tags": [
      {
        "title": "param",
        "description": "a geojson feature",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "feature"
      },
      {
        "title": "param",
        "description": "the precision at which the geohash will be created",
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "precision"
      },
      {
        "title": "returns",
        "description": "geohash",
        "type": {
          "type": "NameExpression",
          "name": "string"
        }
      },
      {
        "title": "name",
        "name": "createGeohash"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 585,
          "column": 2
        },
        "end": {
          "line": 594,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L585-L594"
    },
    "params": [
      {
        "title": "param",
        "description": "a geojson feature",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "feature"
      },
      {
        "title": "param",
        "description": "the precision at which the geohash will be created",
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "precision"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "geohash",
        "type": {
          "type": "NameExpression",
          "name": "string"
        }
      }
    ],
    "name": "createGeohash",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "createGeohash"
    ]
  },
  {
    "description": "Create a \"like\" filter for query string values",
    "tags": [
      {
        "title": "param",
        "description": "a sql where clause",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "sql"
      },
      {
        "title": "param",
        "description": "a list of fields in to support coded value domains",
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "fields"
      },
      {
        "title": "name",
        "name": "createLikeFilterFromSql"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 197,
          "column": 2
        },
        "end": {
          "line": 213,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L197-L213"
    },
    "params": [
      {
        "title": "param",
        "description": "a sql where clause",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "sql"
      },
      {
        "title": "param",
        "description": "a list of fields in to support coded value domains",
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "fields"
      }
    ],
    "name": "createLikeFilterFromSql",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "createLikeFilterFromSql"
    ]
  },
  {
    "description": "Creates a \"range\" filter for querying numeric values",
    "tags": [
      {
        "title": "param",
        "description": "a sql where clause",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "sql"
      },
      {
        "title": "param",
        "description": "a list of fields in to support coded value domains",
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "fields"
      },
      {
        "title": "name",
        "name": "createRangeFilterFromSql"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 143,
          "column": 2
        },
        "end": {
          "line": 190,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L143-L190"
    },
    "params": [
      {
        "title": "param",
        "description": "a sql where clause",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "sql"
      },
      {
        "title": "param",
        "description": "a list of fields in to support coded value domains",
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "fields"
      }
    ],
    "name": "createRangeFilterFromSql",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "createRangeFilterFromSql"
    ]
  },
  {
    "description": "Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)",
    "tags": [
      {
        "title": "param",
        "description": "a sql where clause",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "where"
      },
      {
        "title": "param",
        "description": "a list of fields in to support coded value domains",
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "fields"
      },
      {
        "title": "returns",
        "description": "sql",
        "type": {
          "type": "NameExpression",
          "name": "string"
        }
      },
      {
        "title": "name",
        "name": "createWhereFromSql"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 239,
          "column": 2
        },
        "end": {
          "line": 268,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L239-L268"
    },
    "params": [
      {
        "title": "param",
        "description": "a sql where clause",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "where"
      },
      {
        "title": "param",
        "description": "a list of fields in to support coded value domains",
        "type": {
          "type": "NameExpression",
          "name": "Array"
        },
        "name": "fields"
      }
    ],
    "returns": [
      {
        "title": "returns",
        "description": "sql",
        "type": {
          "type": "NameExpression",
          "name": "string"
        }
      }
    ],
    "name": "createWhereFromSql",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "createWhereFromSql"
    ]
  },
  {
    "description": "Drops a table from the DB",
    "tags": [
      {
        "title": "param",
        "description": "the table to drop",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "dropTable"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 626,
          "column": 2
        },
        "end": {
          "line": 628,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L626-L628"
    },
    "params": [
      {
        "title": "param",
        "description": "the table to drop",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "dropTable",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "dropTable"
    ]
  },
  {
    "description": "Get a geohash aggregation for a set of features in the db\nthis will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.",
    "tags": [
      {
        "title": "param",
        "description": "the table to query",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "the max number of geohash to send back",
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "limit"
      },
      {
        "title": "param",
        "description": "the precision at which to extract geohashes",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "precision"
      },
      {
        "title": "param",
        "description": "optional params like where and geometry",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "options"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "geoHashAgg"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 773,
          "column": 2
        },
        "end": {
          "line": 848,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L773-L848"
    },
    "params": [
      {
        "title": "param",
        "description": "the table to query",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "the max number of geohash to send back",
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "limit"
      },
      {
        "title": "param",
        "description": "the precision at which to extract geohashes",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "precision"
      },
      {
        "title": "param",
        "description": "optional params like where and geometry",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "options"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "geoHashAgg",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "geoHashAgg"
    ]
  },
  {
    "description": "Gets the count of all features in a table",
    "tags": [
      {
        "title": "param",
        "description": "the table name",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "optional params from the querystring like where and geometry",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "options"
      },
      {
        "title": "param",
        "description": "returns the count",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "getCount"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 51,
          "column": 2
        },
        "end": {
          "line": 78,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L51-L78"
    },
    "params": [
      {
        "title": "param",
        "description": "the table name",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "optional params from the querystring like where and geometry",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "options"
      },
      {
        "title": "param",
        "description": "returns the count",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "getCount",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "getCount"
    ]
  },
  {
    "description": "Gets the info/metadata from the koopinfo table in the db",
    "tags": [
      {
        "title": "param",
        "description": "the table name",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "returns the info Object",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "getInfo"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 86,
          "column": 2
        },
        "end": {
          "line": 95,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L86-L95"
    },
    "params": [
      {
        "title": "param",
        "description": "the table name",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "returns the info Object",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "getInfo",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "getInfo"
    ]
  },
  {
    "description": "Gets a statistic on one field at a time\nSupports where and geometry filters and group by",
    "tags": [
      {
        "title": "param",
        "description": "to get data from",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "to generate stats from",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "field"
      },
      {
        "title": "param",
        "description": "the name of the stat field",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "outName"
      },
      {
        "title": "param",
        "description": "the stat type: min, max, avg, count, var, stddev",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "type"
      },
      {
        "title": "param",
        "description": "optional params for the query: where, geometry, groupBy",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "options"
      },
      {
        "title": "param",
        "description": "when the query is done",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "getStat"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 886,
          "column": 2
        },
        "end": {
          "line": 952,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L886-L952"
    },
    "params": [
      {
        "title": "param",
        "description": "to get data from",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "to generate stats from",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "field"
      },
      {
        "title": "param",
        "description": "the name of the stat field",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "outName"
      },
      {
        "title": "param",
        "description": "the stat type: min, max, avg, count, var, stddev",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "type"
      },
      {
        "title": "param",
        "description": "optional params for the query: where, geometry, groupBy",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "options"
      },
      {
        "title": "param",
        "description": "when the query is done",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "getStat",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "getStat"
    ]
  },
  {
    "description": "Creates a table and inserts features and metadat\ncreates indexes for each property in the features and substring indexes on geohashes",
    "tags": [
      {
        "title": "param",
        "description": "the dataset id to insert into",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "id"
      },
      {
        "title": "param",
        "description": "geojson features",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "geojson"
      },
      {
        "title": "param",
        "description": "the layer id for this dataset",
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "layerId"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "insert"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 436,
          "column": 2
        },
        "end": {
          "line": 524,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L436-L524"
    },
    "params": [
      {
        "title": "param",
        "description": "the dataset id to insert into",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "id"
      },
      {
        "title": "param",
        "description": "geojson features",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "geojson"
      },
      {
        "title": "param",
        "description": "the layer id for this dataset",
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "layerId"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "insert",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "insert"
    ]
  },
  {
    "description": "Inserts an array of features\nused as a way to insert pages of features, and only features, not metadata",
    "tags": [
      {
        "title": "param",
        "description": "the dataset id to insert into",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "id"
      },
      {
        "title": "param",
        "description": "geojson features",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "geojson"
      },
      {
        "title": "param",
        "description": "the layer id for this dataset",
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "layerId"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "insertPartial"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 535,
          "column": 2
        },
        "end": {
          "line": 555,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L535-L555"
    },
    "params": [
      {
        "title": "param",
        "description": "the dataset id to insert into",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "id"
      },
      {
        "title": "param",
        "description": "geojson features",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "geojson"
      },
      {
        "title": "param",
        "description": "the layer id for this dataset",
        "type": {
          "type": "NameExpression",
          "name": "number"
        },
        "name": "layerId"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "insertPartial",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "insertPartial"
    ]
  },
  {
    "description": "Parses a geometry Object",
    "tags": [
      {
        "title": "param",
        "description": "a geometry used for filtering data spatially",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "geometry"
      },
      {
        "title": "name",
        "name": "parseGeometry"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 385,
          "column": 2
        },
        "end": {
          "line": 425,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L385-L425"
    },
    "params": [
      {
        "title": "param",
        "description": "a geometry used for filtering data spatially",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "geometry"
      }
    ],
    "name": "parseGeometry",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "parseGeometry"
    ]
  },
  {
    "description": "Removes everything in the DB for a given idea\nwill delete all metadata, timers, and features   *",
    "tags": [
      {
        "title": "param",
        "description": "the dataset id to remove",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "id"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "remove"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 602,
          "column": 2
        },
        "end": {
          "line": 618,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L602-L618"
    },
    "params": [
      {
        "title": "param",
        "description": "the dataset id to remove",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "id"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "remove",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "remove"
    ]
  },
  {
    "description": "Get features out of the db",
    "tags": [
      {
        "title": "param",
        "description": "the dataset id to insert into",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "id"
      },
      {
        "title": "param",
        "description": "optional params used for filtering features (where, geometry, etc)",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "options"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "select"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 277,
          "column": 2
        },
        "end": {
          "line": 378,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L277-L378"
    },
    "params": [
      {
        "title": "param",
        "description": "the dataset id to insert into",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "id"
      },
      {
        "title": "param",
        "description": "optional params used for filtering features (where, geometry, etc)",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "options"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "select",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "select"
    ]
  },
  {
    "description": "Gets the count of the number of services registered for a given type",
    "tags": [
      {
        "title": "param",
        "description": "the type of service: agol, socrata, ckan, etc.",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "type"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "serviceCount"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 663,
          "column": 2
        },
        "end": {
          "line": 672,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L663-L672"
    },
    "params": [
      {
        "title": "param",
        "description": "the type of service: agol, socrata, ckan, etc.",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "type"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "serviceCount",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "serviceCount"
    ]
  },
  {
    "description": "Gets a service for a given type and id\nif no id is sent it returns an array of every service for that type",
    "tags": [
      {
        "title": "param",
        "description": "the type of service: agol, socrata, ckan, etc.",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "type"
      },
      {
        "title": "param",
        "description": "the id to use for the service",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "id"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "serviceGet"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 696,
          "column": 2
        },
        "end": {
          "line": 715,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L696-L715"
    },
    "params": [
      {
        "title": "param",
        "description": "the type of service: agol, socrata, ckan, etc.",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "type"
      },
      {
        "title": "param",
        "description": "the id to use for the service",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "id"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "serviceGet",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "serviceGet"
    ]
  },
  {
    "description": "Register a new service in the DB with the given type and info",
    "tags": [
      {
        "title": "param",
        "description": "the type of service: agol, socrata, ckan, etc.",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "type"
      },
      {
        "title": "param",
        "description": "Object containing a host and id for this service",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "info"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "serviceRegister"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 637,
          "column": 2
        },
        "end": {
          "line": 655,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L637-L655"
    },
    "params": [
      {
        "title": "param",
        "description": "the type of service: agol, socrata, ckan, etc.",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "type"
      },
      {
        "title": "param",
        "description": "Object containing a host and id for this service",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "info"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "serviceRegister",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "serviceRegister"
    ]
  },
  {
    "description": "Removes a service for a given type and id from the DB",
    "tags": [
      {
        "title": "param",
        "description": "the type of service: agol, socrata, ckan, etc.",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "type"
      },
      {
        "title": "param",
        "description": "the id to use for the service",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "id"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "serviceRemove"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 681,
          "column": 2
        },
        "end": {
          "line": 686,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L681-L686"
    },
    "params": [
      {
        "title": "param",
        "description": "the type of service: agol, socrata, ckan, etc.",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "type"
      },
      {
        "title": "param",
        "description": "the id to use for the service",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "id"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "serviceRemove",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "serviceRemove"
    ]
  },
  {
    "description": "Gets the current timer for a given table\ntimers are used throttle API calls by preventing providers from   * over-calling an API.",
    "tags": [
      {
        "title": "param",
        "description": "the table to query",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "timerGet"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 745,
          "column": 2
        },
        "end": {
          "line": 757,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L745-L757"
    },
    "params": [
      {
        "title": "param",
        "description": "the table to query",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "timerGet",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "timerGet"
    ]
  },
  {
    "description": "Sets new timer for a given table",
    "tags": [
      {
        "title": "param",
        "description": "the table to query",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "timerSet"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 723,
          "column": 2
        },
        "end": {
          "line": 736,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L723-L736"
    },
    "params": [
      {
        "title": "param",
        "description": "the table to query",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "the callback when the query returns",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "timerSet",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "timerSet"
    ]
  },
  {
    "description": "Updates/overwrites the info/metadata for dataset in the db",
    "tags": [
      {
        "title": "param",
        "description": "the table name",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "the metadata Object to insert into the koopinfo table",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "info"
      },
      {
        "title": "param",
        "description": "returns the info Object",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      },
      {
        "title": "name",
        "name": "updateInfo"
      },
      {
        "title": "kind",
        "kind": "function"
      },
      {
        "title": "memberof",
        "description": "module.exports"
      },
      {
        "title": "static"
      }
    ],
    "context": {
      "loc": {
        "start": {
          "line": 105,
          "column": 2
        },
        "end": {
          "line": 114,
          "column": 3
        }
      },
      "file": "/Users/chelm/dev/koop-sample-app/node_modules/koop-pgcache/index.js",
      "code": "{\n  geohashPrecision: 8,\n  infoTable: 'koopinfo',\n  timerTable: 'kooptimers',\n  limit: 2000,\n\n  /**\n   * Connect to the db with a connection string\n   *\n   * @param {string} conn - the connection string to the db with user/pass/host/dbname\n   * @param {Object} koop - an instance of koop, mainlt for central/shared logging\n   * @param {function} optional callback for when the db is ready\n   */\n  connect: function (conn, koop, callback) {\n    var self = this\n    // use the koop logger\n    this.log = koop.log\n    // save the connection string\n    this.conn = conn\n\n    this.client = new Pg.Client(conn)\n    this.client.connect(function (err) {\n      if (err) {\n        console.log('Could not connect to the database: ' + err.message)\n        process.exit()\n      } else {\n        // creates table only if they dont exist\n        self._createTable(self.infoTable, '(id varchar(255) PRIMARY KEY, info JSON)', null)\n        self._createTable(self.timerTable, '(id varchar(255) PRIMARY KEY, expires varchar(25))', null)\n      }\n      if (callback) {\n        callback()\n      }\n    })\n    return this\n  },\n\n  /**\n   * Gets the count of all features in a table\n   *\n   * @param {string} table - the table name\n   * @param {Object} options - optional params from the querystring like where and geometry\n   * @param {function} callback - returns the count\n   */\n  getCount: function (table, options, callback) {\n    var self = this\n    var select = 'select count(*) as count from \"' + table + '\"'\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        select += ' WHERE ' + clause\n      } else {\n        select += ' WHERE ' + options.where\n      }\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      select += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      select += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    this._query(select, function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        self.log.debug('Get Count', result.rows[0].count, select)\n        callback(null, parseInt(result.rows[0].count, 10))\n      }\n    })\n  },\n\n  /**\n   * Gets the info/metadata from the koopinfo table in the db\n   *\n   * @param {string} table - the table name\n   * @param {function} callback - returns the info Object\n   */\n  getInfo: function (table, callback) {\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + table + \":info\\'\", function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        var info = result.rows[0].info\n        callback(null, info)\n      }\n    })\n  },\n\n  /**\n   * Updates/overwrites the info/metadata for dataset in the db\n   *\n   * @param {string} table - the table name\n   * @param {Object} info - the metadata Object to insert into the koopinfo table\n   * @param {function} callback - returns the info Object\n   */\n  // updates the info doc for a key\n  updateInfo: function (table, info, callback) {\n    this.log.debug('Updating info %s %s', table, info.status)\n    this._query('update ' + this.infoTable + ' set info = \\'' + JSON.stringify(info) + '\\' where id = \\'' + table + ':info\\'', function (err, result) {\n      if (err || !result) {\n        callback('Key Not Found ' + table, null)\n      } else {\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Check for any coded values in the fields\n   * if we find a match, replace value with the coded val\n   *\n   * @param {string} fieldName - the name of field to look for\n   * @param {number} value - the coded value\n   * @param {Array} fields - a list of fields to use for coded value replacements\n   */\n  applyCodedDomains: function (fieldName, value, fields) {\n    fields.forEach(function (field) {\n      if (field.domain && (field.domain.name && field.domain.name === fieldName)) {\n        field.domain.codedValues.forEach(function (coded) {\n          if (parseInt(coded.code, 10) === parseInt(value, 10)) {\n            value = coded.name\n          }\n        })\n      }\n    })\n    return value\n  },\n\n  /**\n   * Creates a \"range\" filter for querying numeric values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createRangeFilterFromSql: function (sql, fields) {\n    var terms, type\n\n    if (sql.indexOf(' >= ') > -1) {\n      terms = sql.split(' >= ')\n      type = '>='\n    } else if (sql.indexOf(' <= ') > -1) {\n      terms = sql.split(' <= ')\n      // paramIndex = 1\n      type = '<='\n    } else if (sql.indexOf(' = ') > -1) {\n      terms = sql.split(' = ')\n      // paramIndex = 1\n      type = '='\n    } else if (sql.indexOf(' > ') > -1) {\n      terms = sql.split(' > ')\n      // paramIndex = 1\n      type = '>'\n    } else if (sql.indexOf(' < ') > -1) {\n      terms = sql.split(' < ')\n      // paramIndex = 1\n      type = '<'\n    }\n\n    if (terms.length !== 2) { return }\n\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n    var value = terms[1]\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n\n    if (parseInt(value, 10) || parseInt(value, 10) === 0) {\n      if (((parseFloat(value) === parseInt(value, 10)) && !isNaN(value)) || value === 0) {\n        field += '::float::int'\n      } else {\n        field += '::float'\n      }\n      return field + ' ' + type + ' ' + value\n    } else {\n      return field + ' ' + type + ' \\'' + value.replace(/'/g, '') + '\\''\n    }\n\n  },\n   /**\n   * Create a \"like\" filter for query string values\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createLikeFilterFromSql: function (sql, fields) {\n    var terms = sql.split(' like ')\n    if (terms.length !== 2) { return }\n\n    // replace N for unicode values so we can rehydrate filter pages\n    var value = terms[1].replace(/^N'/g, '\\'') // .replace(/^\\'%|%\\'$/g, '')\n    // to support downloads we set quotes on unicode fieldname, here we remove them\n    var fieldName = terms[0].replace(/\\'([^\\']*)'/g, '$1')\n\n    // check for fields and apply any coded domains\n    if (fields) {\n      value = this.applyCodedDomains(fieldName, value, fields)\n    }\n\n    var field = ' (feature->\\'properties\\'->>\\'' + fieldName + '\\')'\n    return field + ' ilike ' + value\n  },\n\n  /**\n   * Determines if a range or like filter is needed   * appends directly to the sql passed in\n   *\n   * @param {string} sql - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   */\n  createFilterFromSql: function (sql, fields) {\n    if (sql.indexOf(' like ') > -1) {\n      // like\n      return this.createLikeFilterFromSql(sql, fields)\n\n    } else if (sql.indexOf(' < ') > -1 || sql.indexOf(' > ') > -1 || sql.indexOf(' >= ') > -1 || sql.indexOf(' <= ') > -1 || sql.indexOf(' = ') > -1) {\n      // part of a range\n      return this.createRangeFilterFromSql(sql, fields)\n    }\n  },\n\n  /**\n   * Creates a viable SQL where clause from a passed in SQL (from a url \"where\" param)\n   *\n   * @param {string} where - a sql where clause\n   * @param {Array} fields - a list of fields in to support coded value domains\n   * @returns {string} sql\n   */\n  createWhereFromSql: function (where, fields) {\n    var self = this\n    var terms = where.split(' AND ')\n    var pairs, andWhere = [], orWhere = []\n    // var filter\n\n    terms.forEach(function (term) {\n      // trim spaces\n      term = term.trim()\n      // remove parens\n      term = term.replace(/(^\\()|(\\)$)/g, '')\n      pairs = term.split(' OR ')\n      if (pairs.length > 1) {\n        pairs.forEach(function (item) {\n          orWhere.push(self.createFilterFromSql(item, fields))\n        })\n      } else {\n        pairs.forEach(function (item) {\n          andWhere.push(self.createFilterFromSql(item, fields))\n        })\n      }\n    })\n    var sql = []\n    if (andWhere.length) {\n      sql.push(andWhere.join(' AND '))\n    } else if (orWhere.length) {\n      sql.push('(' + orWhere.join(' OR ') + ')')\n    }\n    return sql.join(' AND ')\n  },\n\n  /**\n   * Get features out of the db\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} options - optional params used for filtering features (where, geometry, etc)\n   * @param {function} callback - the callback when the query returns\n   */\n  select: function (id, options, callback) {\n    var self = this\n    var layer = (options.layer || 0)\n\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':' + layer + ':info') + '\\'', function (err, result) {\n      if (err || !result || !result.rows || !result.rows.length) {\n        callback('Not Found', [])\n      } else if (result.rows[0].info.status === 'processing' && !options.bypassProcessing) {\n        callback(null, [{ status: 'processing' }])\n      } else {\n        var info = result.rows[0].info\n        var select\n        if (options.simplify) {\n          select = 'select id, feature->>\\'properties\\' as props, st_asgeojson(ST_SimplifyPreserveTopology(ST_GeomFromGeoJSON(feature->>\\'geometry\\'), ' + options.simplify + ')) as geom from \"' + id + ':' + (options.layer || 0) + '\"'\n        } else {\n          select = 'select id, feature->>\\'properties\\' as props, feature->>\\'geometry\\' as geom from \"' + id + ':' + layer + '\"'\n        }\n\n        // parse the where clause\n        if (options.where) {\n          if (options.where !== '1=1') {\n            var clause = self.createWhereFromSql(options.where, options.fields)\n            select += ' WHERE ' + clause\n          } else {\n            select += ' WHERE ' + options.where\n          }\n          if (options.idFilter) {\n            select += ' AND ' + options.idFilter\n          }\n        } else if (options.idFilter) {\n          select += ' WHERE ' + options.idFilter\n        }\n\n        // parse the geometry param from GeoServices REST\n        var box = self.parseGeometry(options.geometry)\n        if (box) {\n          select += (options.where || options.idFilter) ? ' AND ' : ' WHERE '\n          var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n          select += 'ST_GeomFromGeoJSON(feature->>\\'geometry\\') && ST_SetSRID(\\'BOX3D(' + bbox + ')\\'::box3d,4326)'\n        }\n\n        self._query(select.replace(/ id, feature->>'properties' as props, feature->>'geometry' as geom /, ' count(*) as count '), function (err, result) {\n          if (!options.limit && !err && result.rows.length && (result.rows[0].count > self.limit && options.enforce_limit)) {\n            callback(null, [{\n              exceeds_limit: true,\n              type: 'FeatureCollection',\n              features: [{}],\n              name: info.name,\n              sha: info.sha,\n              info: info.info,\n              updated_at: info.updated_at,\n              retrieved_at: info.retrieved_at,\n              expires_at: info.expires_at,\n              count: result.rows[0].count\n            }])\n\n          } else {\n            // ensure id order \\\n            select += ' ORDER BY id'\n            if (options.limit) {\n              select += ' LIMIT ' + options.limit\n            }\n            if (options.offset) {\n              select += ' OFFSET ' + options.offset\n            }\n            self.log.debug('Selecting data', select)\n            self._query(select, function (err, result) {\n              if (err) self.log.error(err)\n              if (result && result.rows && result.rows.length) {\n                var features = []\n                  // feature\n                result.rows.forEach(function (row, i) {\n                  features.push({\n                    'type': 'Feature',\n                    'id': row.id,\n                    'geometry': JSON.parse(row.geom),\n                    'properties': JSON.parse(row.props)\n                  })\n                })\n                callback(null, [{\n                  type: 'FeatureCollection',\n                  features: features,\n                  name: info.name,\n                  sha: info.sha,\n                  info: info.info,\n                  updated_at: info.updated_at,\n                  retrieved_at: info.retrieved_at,\n                  expires_at: info.expires_at,\n                  count: result.rows.length\n                }])\n              } else {\n                callback('Not Found', [{\n                  type: 'FeatureCollection',\n                  features: []\n                }])\n              }\n            })\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Parses a geometry Object\n   *\n   * @param {string} geometry - a geometry used for filtering data spatially\n   */\n  parseGeometry: function (geometry) {\n    var geom = geometry\n    var bbox\n    if (!geom) {\n      return false\n    }\n    if (typeof (geom) === 'string') {\n      try {\n        geom = JSON.parse(geom)\n      } catch(e) {\n        try {\n          if (geom.split(',').length === 4) {\n            bbox = { spatialReference: {wkid: 4326} }\n            var extent = geom.split(',')\n            bbox.xmin = extent[0]\n            bbox.ymin = extent[1]\n            bbox.xmax = extent[2]\n            bbox.ymax = extent[3]\n          }\n        } catch(error) {\n          this.log.error('Error building bbox from query ' + geometry)\n        }\n      }\n    } else if (geom && (geom.xmin || geom.xmin === 0) && (geom.ymin || geom.ymin === 0) && geom.spatialReference && geom.spatialReference.wkid !== 4326) {\n      // is this a valid geometry Object that has a spatial ref different than 4326?\n      var mins = merc.inverse([geom.xmin, geom.ymin]),\n        maxs = merc.inverse([geom.xmax, geom.ymax])\n      bbox = { spatialReference: {wkid: 4326} }\n      bbox.xmin = mins[0]\n      bbox.ymin = mins[1]\n      bbox.xmax = maxs[0]\n      bbox.ymax = maxs[1]\n    }\n    // check to make sure everything is numeric\n    if (this.isNumeric(bbox.xmin) && this.isNumeric(bbox.xmax) &&\n        this.isNumeric(bbox.ymin) && this.isNumeric(bbox.ymax)) {\n      return bbox\n    } else {\n      return false\n    }\n  },\n\n  /**\n   * Creates a table and inserts features and metadat\n   * creates indexes for each property in the features and substring indexes on geohashes\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insert: function (id, geojson, layerId, callback) {\n    var self = this\n    var info = {}\n\n    info.name = geojson.name\n    info.updated_at = geojson.updated_at\n    info.expires_at = geojson.expires_at\n    info.retrieved_at = geojson.retrieved_at\n    info.status = geojson.status\n    info.format = geojson.format\n    info.sha = geojson.sha\n    info.info = geojson.info\n    info.host = geojson.host\n\n    var table = id + ':' + layerId\n    var feature = (geojson.length) ? geojson[0].features[0] : geojson.features[0]\n\n    var types = {\n      'esriGeometryPolyline': 'Linestring',\n      'esriGeometryPoint': 'Point',\n      'esriGeometryPolygon': 'Polygon'\n    }\n\n    if (!feature) {\n      feature = { geometry: { type: geojson.geomType || types[geojson.info.geometryType] } }\n    }\n\n    // a list of indexes to create on the new table\n    var indexes = [{\n      name: 'gix',\n      using: 'GIST (ST_GeomfromGeoJSON(feature->>\\'geometry\\'))'\n    }, {\n      name: 'substr3',\n      using: 'btree (substring(geohash,0,3))'\n    }, {\n      name: 'substr4',\n      using: 'btree (substring(geohash,0,4))'\n    }, {\n      name: 'substr5',\n      using: 'btree (substring(geohash,0,5))'\n    }, {\n      name: 'substr6',\n      using: 'btree (substring(geohash,0,6))'\n    }, {\n      name: 'substr7',\n      using: 'btree (substring(geohash,0,7))'\n    }, {\n      name: 'substr8',\n      using: 'btree (substring(geohash,0,8))'\n    }]\n\n    // for each property in the data create an index\n    if (geojson.info && geojson.info.fields) {\n      geojson.info.fields.forEach(function (field) {\n        var idx = {\n          name: field,\n          using: 'btree ((feature->\\'properties\\'->>\\'' + field + '\\'))'\n        }\n        indexes.push(idx)\n      })\n    }\n\n    self._createTable(table, self._buildSchemaFromFeature(feature), indexes, function (err) {\n      if (err) {\n        callback(err, false)\n        return\n      }\n\n      // insert each feature\n      if (geojson.length) {\n        geojson = geojson[0]\n      }\n      geojson.features.forEach(function (feature, i) {\n        self._query(self._insertFeature(table, feature, i), function (err) {\n          if (err) {\n            self.log.error(err)\n          }\n        })\n      })\n\n      // TODO Why not use an update query here?\n      self._query('delete from \"' + self.infoTable + '\" where id=\\'' + table + ':info\\'', function (err, res) {\n        if (err) self.log.error(err)\n        self._query('insert into \"' + self.infoTable + '\" values (\\'' + table + ':info\\',\\'' + JSON.stringify(info).replace(/'/g, '') + '\\')', function (err, result) {\n          callback(err, true)\n        })\n      })\n    })\n  },\n\n  /**\n   * Inserts an array of features\n   * used as a way to insert pages of features, and only features, not metadata\n   *\n   * @param {string} id - the dataset id to insert into\n   * @param {Object} geojson - geojson features\n   * @param {number} layerId - the layer id for this dataset\n   * @param {function} callback - the callback when the query returns\n   */\n  insertPartial: function (id, geojson, layerId, callback) {\n    var self = this\n    var sql = 'BEGIN'\n    var table = id + ':' + layerId\n\n    geojson.features.forEach(function (feature, i) {\n      sql += self._insertFeature(table, feature, i)\n    })\n    sql += 'COMMIT'\n    this._query(sql, function (err, res) {\n      if (err) {\n        self.log.error('insert partial ERROR %s, %s', err, id)\n        self._query('ROLLBACK', function () {\n          callback(err, false)\n        })\n      } else {\n        self.log.debug('insert partial SUCCESS %s', id)\n        callback(null, true)\n      }\n    })\n  },\n\n  /**\n   * Creates the sql needed to insert the feature\n   *\n   * @param {string} table - the table to insert into\n   * @param {Object} feature - a geojson feature\n   * @param {string} i - index value to use an id\n   * @private\n   */\n  _insertFeature: function (table, feature, i) {\n    var featurestring = JSON.stringify(feature).replace(/'/g, '')\n\n    if (feature.geometry && feature.geometry.coordinates && feature.geometry.coordinates.length) {\n      var geohash = this.createGeohash(feature, this.geohashPrecision)\n      feature.geometry.crs = {'type': 'name', 'properties': {'name': 'EPSG:4326'}}\n      return 'insert into \"' + table + '\" (feature, geohash) VALUES (\\'' + featurestring + '\\', \\'' + geohash + '\\')'\n    } else {\n      return 'insert into \"' + table + '\" (feature) VALUES (\\'' + featurestring + '\\')'\n    }\n  },\n\n  /**\n   * Creates a geohash from a features\n   * computes the centroid of lines and polygons\n   *\n   * @param {Object} feature - a geojson feature\n   * @param {number} precision - the precision at which the geohash will be created\n   * @returns {string} geohash\n   */\n  createGeohash: function (feature, precision) {\n    if (!feature.geometry || !feature.geometry.coordinates) {\n      return\n    }\n    if (feature.geometry.type !== 'Point') {\n      feature = centroid(feature)\n    }\n    var pnt = feature.geometry.coordinates\n    return ngeohash.encode(pnt[1], pnt[0], precision)\n  },\n\n  /**\n   * Removes everything in the DB for a given idea\n   * will delete all metadata, timers, and features   *\n   * @param {string} id - the dataset id to remove\n   * @param {function} callback - the callback when the query returns\n   */\n  remove: function (id, callback) {\n    var self = this\n    this._query('select info from \"' + this.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n      if (err) self.log.error(err)\n      if (!result || !result.rows.length) {\n        // nothing to remove\n        callback(null, true)\n      } else {\n        self.dropTable(id, function (err, result) {\n          if (err) self.log.error(err)\n          self._query('delete from \"' + self.infoTable + '\" where id=\\'' + (id + ':info') + '\\'', function (err, result) {\n            if (callback) callback(err, true)\n          })\n        })\n      }\n    })\n  },\n\n  /**\n   * Drops a table from the DB\n   *\n   * @param {string} table - the table to drop\n   * @param {function} callback - the callback when the query returns\n   */\n  dropTable: function (table, callback) {\n    this._query('drop table \"' + table + '\"', callback)\n  },\n\n  /**\n   * Register a new service in the DB with the given type and info\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {Object} info - Object containing a host and id for this service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRegister: function (type, info, callback) {\n    var self = this\n    this._createTable(type, '(id varchar(100), host varchar(100))', null, function (err, result) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('select * from \"' + type + '\" where id=\\'' + info.id + \"\\'\", function (err, res) {\n          if (err || !res || !res.rows || !res.rows.length) {\n            var sql = 'insert into \"' + type + '\" (id, host) VALUES (\\'' + info.id + '\\', \\'' + info.host + '\\')'\n            self._query(sql, function (err, res) {\n              callback(err, true)\n            })\n          } else {\n            callback(err, true)\n          }\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the count of the number of services registered for a given type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceCount: function (type, callback) {\n    var sql = 'select count(*) as count from \"' + type + '\"'\n    this._query(sql, function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, 0)\n      } else {\n        callback(err, res.rows[0].count)\n      }\n    })\n  },\n\n  /**\n   * Removes a service for a given type and id from the DB\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceRemove: function (type, id, callback) {\n    var sql = 'delete from \"' + type + '\" where id=\\'' + id + \"'\"\n    this._query(sql, function (err, res) {\n      callback(err, true)\n    })\n  },\n\n  /**\n   * Gets a service for a given type and id\n   * if no id is sent it returns an array of every service for that type\n   *\n   * @param {string} type - the type of service: agol, socrata, ckan, etc.\n   * @param {string} id - the id to use for the service\n   * @param {function} callback - the callback when the query returns\n   */\n  serviceGet: function (type, id, callback) {\n    var self = this\n    var sql\n    if (!id) {\n      sql = 'select * from \"' + type + '\"'\n      self._query(sql, function (err, res) {\n        callback(err, (res) ? res.rows : null)\n      })\n    } else {\n      sql = 'select * from \"' + type + '\" where id=\\'' + id + \"\\'\"\n      self._query(sql, function (err, res) {\n        if (err || !res || !res.rows || !res.rows.length) {\n          err = 'No service found by that id'\n          callback(err, null)\n        } else {\n          callback(err, res.rows[0])\n        }\n      })\n    }\n  },\n\n  /**\n   * Sets new timer for a given table\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerSet: function (key, expires, callback) {\n    var self = this\n    var now = new Date()\n    var expires_at = new Date(now.getTime() + expires)\n    this._query('delete from \"' + this.timerTable + '\" WHERE id=\\'' + key + \"\\'\", function (err, res) {\n      if (err) {\n        callback(err)\n      } else {\n        self._query('insert into \"' + self.timerTable + '\" (id, expires) VALUES (\\'' + key + '\\', \\'' + expires_at.getTime() + '\\')', function (err, res) {\n          callback(err, res)\n        })\n      }\n    })\n  },\n\n  /**\n   * Gets the current timer for a given table\n   * timers are used throttle API calls by preventing providers from   * over-calling an API.\n   *\n   * @param {string} table - the table to query\n   * @param {function} callback - the callback when the query returns\n   */\n  timerGet: function (table, callback) {\n    this._query('select * from \"' + this.timerTable + '\" where id=\\'' + table + '\\'', function (err, res) {\n      if (err || !res || !res.rows || !res.rows.length) {\n        callback(err, null)\n      } else {\n        if (new Date().getTime() < parseInt(res.rows[0].expires, 10)) {\n          callback(err, res.rows[0])\n        } else {\n          callback(err, null)\n        }\n      }\n    })\n  },\n\n  isNumeric: function (num) {\n    return (num >= 0 || num < 0)\n  },\n\n  /**\n   * Get a geohash aggregation for a set of features in the db\n   * this will auto-reduce the precision of the geohashes if the given   * precision exceeds the given limit.\n   *\n   * @param {string} table - the table to query\n   * @param {number} limit - the max number of geohash to send back\n   * @param {string} precision - the precision at which to extract geohashes\n   * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  geoHashAgg: function (table, limit, precision, options, callback) {\n    var self = this\n    options.whereFilter = null\n    options.geomFilter = null\n\n    // parse the where clause\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        options.whereFilter = ' WHERE ' + clause\n      } else {\n        options.whereFilter = ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    // parse the geometry into a bbox\n    if (box) {\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      options.geomFilter = \" ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    // recursively get geohash counts until we have a precision\n    // that reutrns less than the row limit\n    // this will return the precision that will return the number\n    // of geohashes less than the limit\n    var reducePrecision = function (table, p, options, callback) {\n      self.countDistinctGeoHash(table, p, options, function (err, count) {\n        if (parseInt(count, 0) > limit) {\n          reducePrecision(table, p - 1, options, callback)\n        } else {\n          callback(err, p)\n        }\n      })\n    }\n\n    var agg = {}\n\n    reducePrecision(table, precision, options, function (err, newPrecision) {\n      if (err) self.log.error(err)\n\n      var geoHashSelect\n\n      if (newPrecision <= precision) {\n        geoHashSelect = 'substring(geohash,0,' + (newPrecision) + ')'\n      } else {\n        geoHashSelect = 'geohash'\n      }\n\n      var sql = 'SELECT count(id) as count, ' + geoHashSelect + ' as geohash from \"' + table + '\"'\n\n      // apply any filters to the sql\n      if (options.whereFilter) {\n        sql += options.whereFilter\n      }\n      if (options.geomFilter) {\n        sql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n      }\n\n      sql += ' GROUP BY ' + geoHashSelect\n      self.log.info('GEOHASH Query', sql)\n      self._query(sql, function (err, res) {\n        if (!err && res && res.rows.length) {\n          res.rows.forEach(function (row) {\n            agg[row.geohash] = row.count\n          })\n          callback(err, agg)\n        } else {\n          callback(err, res)\n        }\n      })\n    })\n\n  },\n\n  /**\n   * Get the count of distinct geohashes for a query\n   *\n   * @param {string} table - the table to query\n   * @param {string} precision - the precision at which to extract the distinct geohash counts    * @param {Object} options - optional params like where and geometry\n   * @param {function} callback - the callback when the query returns\n   */\n  countDistinctGeoHash: function (table, precision, options, callback) {\n    var countSql = 'select count(DISTINCT(substring(geohash,0,' + precision + '))) as count from \"' + table + '\"'\n\n    // apply any filters to the sql\n    if (options.whereFilter) {\n      countSql += options.whereFilter\n    }\n\n    if (options.geomFilter) {\n      countSql += ((options.whereFilter) ? ' AND ' : ' WHERE ') + options.geomFilter\n    }\n\n    this.log.debug(countSql)\n    this._query(countSql, function (err, res) {\n      if (err) return callback(err, null)\n      callback(null, res.rows[0].count)\n    })\n  },\n\n  /**\n   * Gets a statistic on one field at a time\n   * Supports where and geometry filters and group by\n   * @param {string} table to get data from\n   * @param {string} field to generate stats from\n   * @param {string} outName the name of the stat field\n   * @param {string} type - the stat type: min, max, avg, count, var, stddev\n   * @param {Object} options - optional params for the query: where, geometry, groupBy\n   * @param {function} callback - when the query is done\n   */\n  getStat: function (table, field, outName, type, options, callback) {\n    // force var to be variance in SQL\n    if (type === 'var') {\n      type = 'variance'\n    }\n    // build sql\n    var fieldName\n    if (type === 'avg' || type === 'sum' || type === 'variance' || type === 'stddev') {\n      fieldName = \"(feature->'properties'->>'\" + field + \"')::int\"\n    } else {\n      fieldName = \"feature->'properties'->>'\" + field + \"'\"\n    }\n    var fieldSql = type.toLowerCase() + '(' + fieldName + ')::int as \"' + outName + '\\\"'\n\n    // add groupby\n    var groupByAs, groupBy\n    if (options.groupby) {\n      if (Array.isArray(options.groupby)) {\n        var gField\n        groupByAs = []\n        groupBy = []\n        options.groupby.forEach(function (f) {\n          gField = \"feature->'properties'->>'\" + f + \"'\"\n          groupBy.push(gField)\n          groupByAs.push(gField + ' as \"' + f + '\"')\n        })\n        groupBy = groupBy.join(', ')\n        groupByAs = groupByAs.join(', ')\n      } else {\n        groupBy = \"feature->'properties'->>'\" + options.groupby + \"'\"\n        groupByAs = groupBy + ' as \"' + options.groupby + '\"'\n      }\n    }\n\n    var sql = 'select ' + fieldSql + ((groupByAs) ? ', ' + groupByAs : '') + ' from \"' + table + '\"'\n\n    // apply where and geometry filter\n    if (options.where) {\n      if (options.where !== '1=1') {\n        var clause = this.createWhereFromSql(options.where)\n        sql += ' WHERE ' + clause\n      } else {\n        sql += ' WHERE ' + options.where\n      }\n      // replace ilike and %% for faster filter queries...\n      options.whereFilter = options.whereFilter.replace(/ilike/g, '=').replace(/%/g, '')\n    }\n\n    var box = this.parseGeometry(options.geometry)\n    if (box) {\n      sql += (options.where) ? ' AND ' : ' WHERE '\n      var bbox = box.xmin + ' ' + box.ymin + ',' + box.xmax + ' ' + box.ymax\n      sql += \"ST_GeomFromGeoJSON(feature->>'geometry') && ST_SetSRID('BOX3D(\" + bbox + \")'::box3d,4326)\"\n    }\n\n    if (groupBy) {\n      sql += 'group by ' + groupBy\n    }\n\n    // issue query\n    this._query(sql, function (err, result) {\n      if (err) {\n        return callback(err)\n      }\n      callback(null, result.rows)\n    })\n  },\n\n  // ---------------\n  // PRIVATE METHODS\n  // ---------------\n\n  /**\n   * Executes SQL again the DB\n   * uses connection pooling to connect and query\n   *\n   * @param {string} sql - the sql to run\n   * @param {function} callback - the callback when db returns\n   * @private\n   */\n  _query: function (sql, callback) {\n    Pg.connect(this.conn, function (err, client, done) {\n      if (err) {\n        return console.error('!error fetching client from pool', err)\n      }\n      client.query(sql, function (err, result) {\n        // call `done()` to release the client back to the pool\n        done()\n        if (callback) {\n          callback(err, result)\n        }\n      })\n    })\n  },\n\n  /**\n   * Creates an index on a given table   *\n   * @param {string} table - the table to index\n   * @param {string} name - the name of the index    * @param {string} using - the actual field and type of the index\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createIndex: function (table, name, using, callback) {\n    var sql = 'CREATE INDEX ' + name + ' ON \"' + table + '\" USING ' + using\n    this._query(sql, function (err) {\n      if (err) {\n        callback(err)\n      } else if (callback) {\n        callback()\n      }\n    })\n  },\n\n  /**\n   * Creates a new table\n   * checks to see if the table exists, create it if not\n   *\n   * @param {string} name - the name of the index    * @param {string} schema - the schema to use for the table   * @param {Array} indexes - an array of indexes to place on the table\n   * @param {function} callback - the callback when the query returns\n   * @private\n   */\n  _createTable: function (name, schema, indexes, callback) {\n    var self = this\n    var sql = 'select exists(select * from information_schema.tables where table_name=\\'' + name + '\\')'\n    this._query(sql, function (err, result) {\n      if (err) {\n        callback('Failed to create table ' + name)\n      } else {\n        if (result && !result.rows[0].exists) {\n          var create = 'CREATE TABLE \"' + name + '\" ' + schema\n          self.log.info(create)\n          self._query(create, function (err, result) {\n            if (err) {\n              callback('Failed to create table ' + name + ' error:' + err)\n              return\n            }\n\n            if (indexes && indexes.length) {\n              var indexName = name.replace(/:|-/g, '')\n              var next = function (idx) {\n                if (!idx) {\n                  if (callback) {\n                    callback()\n                  }\n                } else {\n                  self._createIndex(name, indexName + '_' + idx.name, idx.using, function () {\n                    next(indexes.pop())\n                  })\n                }\n              }\n              next(indexes.pop())\n            } else {\n              if (callback) {\n                callback()\n              }\n            }\n          })\n        } else if (callback) {\n          callback()\n        }\n      }\n    })\n  },\n\n  /**\n   * Builds a table schema from a geojson feature\n   * each schema in the db is essentially the same except for geometry type   * which is based off the geometry of the feature passed in here\n   *\n   * @param {Object} feature - a geojson feature   * @returns {string} schema\n   * @private\n   */\n  _buildSchemaFromFeature: function (feature) {\n    var schema = '('\n    var type\n    if (feature && feature.geometry && feature.geometry.type) {\n      type = feature.geometry.type.toUpperCase()\n    } else {\n      // default to point geoms\n      type = 'POINT'\n    }\n    var props = ['id SERIAL PRIMARY KEY', 'feature JSON', 'geom Geometry(' + type + ', 4326)', 'geohash varchar(10)']\n    schema += props.join(',') + ')'\n    return schema\n  }\n\n}",
      "path": "index.js",
      "github": "https://github.com/koopjs/koop-pgcache/blob/aeded42b5f075829b153f36a2c30562def8a46bc/index.js#L105-L114"
    },
    "params": [
      {
        "title": "param",
        "description": "the table name",
        "type": {
          "type": "NameExpression",
          "name": "string"
        },
        "name": "table"
      },
      {
        "title": "param",
        "description": "the metadata Object to insert into the koopinfo table",
        "type": {
          "type": "NameExpression",
          "name": "Object"
        },
        "name": "info"
      },
      {
        "title": "param",
        "description": "returns the info Object",
        "type": {
          "type": "NameExpression",
          "name": "function"
        },
        "name": "callback"
      }
    ],
    "name": "updateInfo",
    "kind": "function",
    "memberof": "module.exports",
    "scope": "static",
    "members": {
      "instance": [],
      "static": []
    },
    "path": [
      "updateInfo"
    ]
  }
]